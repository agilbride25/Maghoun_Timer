<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MBTA Leave Timer</title>

  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111">

  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 16px; }
    .row { margin: 10px 0; }
    label { display:block; font-size: 14px; margin-bottom: 4px; }
    input { width: 100%; padding: 10px; font-size: 16px; box-sizing: border-box; }
    button { padding: 10px 12px; font-size: 16px; }
    pre { background: #f5f5f5; padding: 12px; border-radius: 10px; white-space: pre-wrap; }
    .small { font-size: 13px; opacity: 0.8; }
  </style>
</head>

<body>
  <h1>MBTA Leave Timer</h1>
  <div class="small">Stop: Magoun Square (place-magou), Route: Green-E, Direction: inbound (1)</div>

  <div class="row">
    <label>Walk time to Magoun (seconds)</label>
    <input id="walkSeconds" type="number" value="600" />
  </div>

  <div class="row">
    <label>Leave-now window (minutes)</label>
    <input id="bufferMinutes" type="number" value="2" />
  </div>

  <div class="row">
    <button id="save">Save</button>
    <button id="check">Check now</button>
  </div>

  <pre id="out">Ready.</pre>

  <script>
    // --- PWA: register service worker ---
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./sw.js").catch(console.error);
    }

    // --- Worker proxy endpoint (your deployed Worker) ---
    const PROXY_PREDICTIONS_URL =
      "https://fancy-feather-4b30.mbtamaghountimer.workers.dev/api/predictions";

    function $(id) { return document.getElementById(id); }

    function loadSettings() {
      $("walkSeconds").value = localStorage.getItem("walkSeconds") || "600";
      $("bufferMinutes").value = localStorage.getItem("bufferMinutes") || "2";
    }

    function saveSettings() {
      localStorage.setItem("walkSeconds", String(Number($("walkSeconds").value || 600)));
      localStorage.setItem("bufferMinutes", String(Number($("bufferMinutes").value || 2)));
      $("out").textContent = "Saved.";
    }

    async function fetchPredictions() {
      const res = await fetch(PROXY_PREDICTIONS_URL, { cache: "no-store" });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`Proxy error ${res.status}: ${text}`);
      }

      return res.json();
    }

    function fmtTime(d) {
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    // --- Leave logic ---
    async function runLeaveLogic() {
      const walkSeconds = Number($("walkSeconds").value || 600);
      const bufferMinutes = Number($("bufferMinutes").value || 2);

      const walkMs = walkSeconds * 1000;
      const bufferMs = bufferMinutes * 60 * 1000;

      $("out").textContent = "Fetching predictionsâ€¦";

      const json = await fetchPredictions();

      const nowMs = Date.now();
      const now = new Date(nowMs);

      // Build sorted list of upcoming predicted times (arrival OR departure)
      const upcoming = (json.data ?? [])
        .map((p) => p.attributes?.arrival_time ?? p.attributes?.departure_time)
        .filter(Boolean)
        .map((t) => new Date(t))
        .filter((d) => d.getTime() >= nowMs)
        .sort((a, b) => a - b);

      if (upcoming.length === 0) {
        $("out").textContent = `Current time: ${fmtTime(now)}\nNo upcoming predicted train times.`;
        return;
      }

      const readyTimeMs = nowMs + walkMs;
      const readyTime = new Date(readyTimeMs);

      // Pick the first train we can actually catch (train_time >= readyTime)
      const catchableIndex = upcoming.findIndex((t) => t.getTime() >= readyTimeMs);

      let output = "";
      output += `Current time: ${fmtTime(now)}\n`;
      output += `Ready time (now + walk): ${fmtTime(readyTime)}\n\n`;

      output += `Next train times:\n`;
      upcoming.slice(0, 2).forEach((t, i) => { output += `  ${i + 1}. ${fmtTime(t)}\n`; });
      output += `\n`;

      if (catchableIndex === -1) {
        output += "No trains are catchable based on walk time (within fetched window).";
        $("out").textContent = output;
        return;
      }

      if (catchableIndex > 0) {
        output += `Skipping ${fmtTime(upcoming[0])} (arrives before you could get there)\n\n`;
      }

      const targetTrain = upcoming[catchableIndex];
      const targetMs = targetTrain.getTime();
      const slackMs = targetMs - readyTimeMs;

      if (slackMs <= bufferMs) {
        output += `LEAVE NOW to catch the ${fmtTime(targetTrain)} train.\n`;
      } else {
        const leaveByMs = targetMs - walkMs;
        const leaveBy = new Date(leaveByMs);
        const waitMs = leaveByMs - nowMs;

        output += `Next catchable train: ${fmtTime(targetTrain)}\n`;
        output += `Leave by: ${fmtTime(leaveBy)} (in ${Math.max(0, Math.round(waitMs / 60000))} min)\n`;
      }

      $("out").textContent = output;
    }

    $("save").addEventListener("click", saveSettings);
    $("check").addEventListener("click", () => runLeaveLogic().catch(e => {
      console.error(e);
      $("out").textContent = `Error: ${e.message}`;
    }));

    loadSettings()

